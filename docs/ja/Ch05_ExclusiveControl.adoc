= 排他制御の機能試験
:table-caption!:
:icons: font
:sectnums!:

== テストケース
テストケースクラス：jp.co.ntt.fw.macchinetta.batch.functionaltest.ch05.ExclusiveControlSpec

[cols="5,25a,70a", options="headers"]
.テストケース一覧
|===
|項番
|テストケース
|確認事項

|1
|<<fileExclusive>>
|
* プロセス間でのファイルの排他制御の実現方法の確認
|2
|<<dbExclusive>>
|
* 楽観ロックの実現方法の確認
** 試験の実施はできるが、結果の検証が難しいかも
* 悲観ロックの実現方法の確認

|===

== 試験項目一覧
各試験の項目一覧を示す。

:sectnums:
:leveloffset: -1

[[fileExclusive]]
=== ファイルの排他制御のテスト
ファイルでの排他制御を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|異常系 +
同期型起動
|プロセス間でのファイルの排他制御の実現方法の確認
|
* FileChannelを使用してファイルをロックしてから、ファイルへの書き込みを行う
** Taskletで実施
** ロックを検出した場合は、ログ出力をして異常終了する
* 同じジョブを２つ以上のプロセスで同時実行する
|
* ログ出力より、ロックを検出したこと
** ロックを検知したジョブが異常終了すること
* 出力ファイルより、期待したファイル出力がされていること

|===


[[dbExclusive]]
=== データベースの排他制御のテスト
データベースでの排他制御を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|楽観ロックの実現方法の確認
|
* チャンクモデルで楽観ロックを行う
** どのプロセスが更新したかわかるようなテーブルにしておく
* テストケースで更新対象のデータを更新ロックにしておく
** その状態で、同じジョブを２つ以上のプロセスで同時実行する
** プロセスがロック待ちになった状態でテストケースからの更新のトランザクションを完了させる
* SQL実行のログ出力を有効にする
** 特にUPDATEの件数が出力できるようにする
* MyBatisBatchItemWriterのassertUpdatesがfalse

icon:tag[] 意図的に楽観ロックが発生する状況を作り出すテスト
|
* 楽観ロックにより更新が発生していないジョブは、正常終了する
* ログ出力により、更新が空振りになったこと
** 更新パラメータを順番に取得
*** １番目のパラメータでテーブルが更新されていること
*** ２番目のパラメータでテーブルが更新されていないこと

icon:tag[] 更新件数がバッチアップデートのため、正確に取らないので更新順番から判断する

|2
|異常系 +
同期型起動
|楽観ロックの実現方法の確認
|
* チャンクモデルで楽観ロックを行う
** どのプロセスが更新したかわかるようなテーブルにしておく
* テストケースで更新対象のデータを更新ロックにしておく
** その状態で、同じジョブを２つ以上のプロセスで同時実行する
** プロセスがロック待ちになった状態でテストケースからの更新のトランザクションを完了させる
* SQL実行のログ出力を有効にする
** 特にUPDATEの件数が出力できるようにする
* MyBatisBatchItemWriterのassertUpdatesがtrue

icon:tag[] 意図的に楽観ロックが発生する状況を作り出すテスト
|
* 楽観ロックにより更新が発生していないジョブは、異常終了する
* ログ出力により、更新が空振りになったこと
** 更新パラメータを順番に取得
*** １番目のパラメータでテーブルが更新されていること
*** ２番目のパラメータでテーブルが更新されていないこと

icon:tag[] 更新件数がバッチアップデートのため、正確に取らないので更新順番から判断する

|3
|正常系 +
同期型起動
|楽観ロックの実現方法の確認
|
* タスクレットモデルで楽観ロックを行う
** どのプロセスが更新したかわかるようなテーブルにしておく
* テストケースで更新対象のデータを更新ロックにしておく
** その状態で、同じジョブを２つ以上のプロセスで同時実行する
** プロセスがロック待ちになった状態でテストケースからの更新のトランザクションを完了させる
* SQL実行のログ出力を有効にする
** 特にUPDATEの件数が出力できるようにする
* MyBatisBatchItemWriterのassertUpdatesがfalse

icon:tag[] 意図的に楽観ロックが発生する状況を作り出すテスト
|
* 楽観ロックにより更新が発生していないジョブは、正常終了する
* ログ出力により、更新が空振りになったこと
** 更新パラメータを順番に取得
*** １番目のパラメータでテーブルが更新されていること
*** ２番目のパラメータでテーブルが更新されていないこと

icon:tag[] 更新件数がバッチアップデートのため、正確に取らないので更新順番から判断する

|4
|異常系 +
同期型起動
|悲観ロックの実現方法の確認
|
* チャンクモデルで悲観ロックを行うジョブを実行する
** NOWAITオプションを使用する
** ロックを検出した場合は、ログ出力をして異常終了する
* テストケースで排他ロックを実行し、ジョブがロック獲得時にエラーとなるようにする
|
* ログ出力より、ロックを検出したこと
** ロックを検知したジョブが異常終了すること

|5
|正常系 +
同期型起動
|悲観ロックの実現方法の確認
|
* チャンクモデルで悲観ロックを行うジョブを実行する
** NOWAITオプションを使用する
** ロックを検出しない場合は、正常終了する

|
* 正常終了すること
* データが更新されていること

|6
|異常系 +
同期型起動
|悲観ロックの実現方法の確認
|
* タスクレットモデルで悲観ロックを行うジョブを実行する
** 単一トランザクションとする
** NOWAITオプションを使用する
** ロックを検出した場合は、ログ出力をして異常終了する
* テストケースで排他ロックを実行し、ジョブがロック獲得時にエラーとなるようにする
|
* ログ出力より、ロックを検出したこと
** ロックを検知したジョブが異常終了すること

|7
|正常系 +
同期型起動
|悲観ロックの実現方法の確認
|
* タスクレットモデルで悲観ロックを行うジョブを実行する
** 単一トランザクションとする
** NOWAITオプションを使用する
** ロックを検出しない場合は、正常終了する

|
* 正常終了すること
* データが更新されていること

|===
