= 例外ハンドリングの機能試験
:table-caption!:
:icons: font
:sectnums!:

== テストケース
テストケースクラス：jp.co.ntt.fw.macchinetta.batch.functionaltest.ch06.ExceptionHandlingSpec

[cols="5,25a,70a", options="headers"]
.テストケース一覧
|===
|項番
|テストケース
|確認事項

|1
|<<stepExceptionHandling>>
|
* チャンクモデルでの例外ハンドリング
** ItemReader
** ItemProcessor
** ItemWriter
** Chunk単位でのハンドリング
* タスクレットモデルでの例外ハンドリング

|2
|<<jobExceptionHandling>>
|
* ジョブ単位での例外ハンドリング
** ステップでの例外ハンドリングからの通知

|3
|<<continuationAvailability>>
|
* スキップ
** チャンクモデル
*** ItemReader
*** ItemProcessor
** タスクレットモデル
* リトライ
** RetryTemplate
* 処理中断

|===

== 試験項目一覧
各試験の項目一覧を示す。

:sectnums:
:leveloffset: -1

[[stepExceptionHandling]]
=== ステップ単位の例外ハンドリングのテスト
ステップ単位の例外ハンドリングを確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|異常系 +
同期型起動
|チャンクモデルのItemReaderにおける例外ハンドリング
|
* 入力データ読み込み時に不正データを読み込むジョブを起動する
* 不正データを検知した場合、ログを出力して異常終了する
|
* ログ出力により、ItemReaderで例外がハンドリングされたこと
* ジョブが異常終了すること

|2
|異常系 +
同期型起動
|チャンクモデルのItemProcessorにおける例外ハンドリング
|
* ItemProcessor実装でビジネス例外が発生するジョブを起動する
* ビジネス例外発生時は、try-catchで例外処理を行い、例外をリスローする
* onProcessErrorでも例外処理を行う
* 例外処理実施箇所がわかるようなログ出力を行う
|
* ログ出力により、ItemProcessorで例外がハンドリングされたこと
** try-catchによりハンドリングされたこと
** onProcessErrorでもハンドリングされたこと
* ジョブが異常終了すること

|3
|異常系 +
同期型起動
|チャンクモデルのItemWriterにおける例外ハンドリング
|
* 出力データ書き込み時に不正データを書き込むジョブを起動する
** DBで定義されている桁数より大きいデータの書き込みなど
* 不正データを検知した場合、ログを出力して異常終了する
|
* ログ出力により、ItemWriterで例外がハンドリングされたこと
* ジョブが異常終了すること

|4
|異常系 +
同期型起動
|タスクレットモデルにおける例外ハンドリング
|
* タスクレット実装でビジネス例外が発生するジョブを起動する
* ビジネス例外発生時は、try-catchで例外処理を行い、例外をリスローする
* 例外を検知した場合はログ出力を行う
|
* ログ出力により、タスクレットモデルで例外がハンドリングされたこと
** try-catchによりハンドリングされたこと
* ジョブが異常終了すること

|5
|異常系 +
同期型起動
|Chunk単位の例外ハンドリング <<tip1>>
|
* チャンクモデル実装で例外が発生するジョブを起動する
** ここでは、Readerでファイルレコード取得に失敗することとする
* ChunkListenerで、検知した例外のログ出力を行う
** ItemReader/ItemProcessor/ItemWriterでは例外ハンドリングは行わない
|
* ログ出力により、ChunkListenerで例外がハンドリングされたこと
* ジョブが異常終了すること

|6
|異常系 +
同期型起動
|Chunk単位の例外ハンドリング <<tip1>>
|
* チャンクモデル実装でItem毎の処理以外で例外が発生するジョブを起動する
** ここでは、Readerでファイルオープンに失敗することとする
* ChunkListenerで、検知した例外のログ出力を行う
** ItemReader/ItemProcessor/ItemWriterでは例外ハンドリングは行わない
|
* ログ出力により、ChunkListenerで例外がハンドリング**されなかった**こと
* ジョブが異常終了すること

|7
|異常系 +
同期型起動
|Chunk単位の例外ハンドリング(Tasklet) <<tip1>>
|
* Taskletモデル実装で例外が発生するジョブを起動する
** ここでは、Readerでファイルレコード取得に失敗することとする
* ChunkListenerで、検知した例外のログ出力を行う
|
* ログ出力により、ChunkListenerで例外がハンドリングされたこと
* ジョブが異常終了すること

|8
|異常系 +
同期型起動
|Chunk単位の例外ハンドリング(Tasklet) <<tip1>>
|
* Taskletモデル実装でItem毎の処理以外で例外が発生するジョブを起動する
** ここでは、Readerでファイルオープンに失敗することとする
* ChunkListenerで、検知した例外のログ出力を行う
|
* ログ出力により、ChunkListenerで例外がハンドリング**された**こと
* ジョブが異常終了すること

|9
|異常系 +
同期型起動
|Step単位の例外ハンドリング <<tip1>>
|
* Chunkモデル実装で例外が発生するジョブを起動する
** ここでは、Readerでファイルレコード取得に失敗することとする
* StepExecutionListenerで、検知した例外のログ出力を行う
|
* StepExecutionListenerで、検知した例外のログ出力を行う
* ジョブが異常終了すること

|10
|異常系 +
同期型起動
|Step単位の例外ハンドリング(Tasklet) <<tip1>>
|
* Taskletモデル実装で例外が発生するジョブを起動する
** ここでは、Readerでファイルレコード取得に失敗することとする
* StepExecutionListenerで、検知した例外のログ出力を行う
|
* StepExecutionListenerで、検知した例外のログ出力を行う
* ジョブが異常終了すること
|===

[[tip1]]
[TIP]
====
.注釈1
ChunkListenerだと、TaskletとChunkで挙動が異なる場合がある。
TaskletはリソースopenはChunkの中、ChunkはリソースOpenはChunkの外。
これはStepExecutionListenerで対処することができる。
====

[[jobExceptionHandling]]
=== ジョブ単位の例外ハンドリングのテスト
ジョブ単位の例外ハンドリングを確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|異常系 +
同期型起動
|ジョブ単位での例外ハンドリングを確認する
|
* ItemProcessor実装でビジネス例外が発生するジョブを起動する
* ビジネス例外発生時は、try-catchで例外処理を行い、例外をリスローする
* onProcessErrorでも例外処理を行う
** エラーが発生したItemの情報を引き継ぐ。
*** 通知するためにItemProcessorでStepExecutionに設定する。
*** 設定した情報はJobExecutionListenerでJobExecutionから辿って取得する。
* afterJobを実装し、例外が発生していることを検知する
** 例外が発生していれば、ログを出力する
|
* ログ出力により、ジョブ単位で例外がハンドリングされていること
** ステップで発生した例外を通知として受け取れること

|===

[[continuationAvailability]]
=== 処理継続可否のテスト
処理継続可否を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|チャンクモデルのItemReaderにおけるスキップ +
常にスキップする
|
* 入力データ読み込み時に不正データを読み込むジョブを起動する
** DBへ更新を行うジョブとする
* 不正データを検知した場合、そのデータをスキップして処理を継続する設定
** `AlwaysSkipItemSkipPolicy`によって実現する
** `SkipListener`によりスキップしたことを検出する
|
* ジョブが正常終了すること
* DBにより、不正データが更新されていないこと
* スキップしたログが出ていること

|2
|異常系 +
同期型起動
|チャンクモデルのItemReaderにおけるスキップ +
常にスキップしない
|
* 入力データ読み込み時に不正データを読み込むジョブを起動する
** DBへ更新を行うジョブとする
* 不正データを検知した場合、そのデータをスキップせず処理を継続する設定
** `NeverSkipItemSkipPolicy`によって実現する
** `SkipListener`によりスキップしたことを検出する
|
* ジョブが異常終了すること
* DBにより、不正データが更新されていないこと

|3
|正常系 +
同期型起動
|チャンクモデルのItemReaderにおけるスキップ +
指定回数/指定した例外をスキップする
|
* 入力データ読み込み時に不正データを読み込むジョブを起動する
** DBへ更新を行うジョブとする
* 不正データを検知した場合、そのデータをスキップして処理を継続する設定
** (デフォルトの)`LimitCheckingItemSkipPolicy`を使い、
    `skippable-exception-classes`で発生しない例外を指定する。
    指定回数よりエラー件数が多いデータを投入する。
** `SkipListener`によりスキップしたことを検出する
|
* ジョブが異常終了すること
* DBにより、不正データが更新されていないこと
* スキップしたログが出ていること

|4
|正常系 +
同期型起動
|チャンクモデルのItemReaderにおけるスキップ +
指定した例外を無制限にスキップする
|
* 入力データ読み込み時に不正データを読み込むジョブを起動する
** DBへ更新を行うジョブとする
* 不正データを検知した場合、そのデータをスキップして処理を継続する設定
** `ExceptionClassifierSkipPolicy`を使う。
** `SkipListener`によりスキップしたことを検出する
|
* ジョブが異常終了すること
* DBにより、不正データが更新されていないこと
* スキップしたログが出ていること

|5
|正常系 +
同期型起動
|チャンクモデルのItemProcessorにおけるスキップ
|
* ItemProcessor実装でビジネス例外が発生するジョブを起動する
* ビジネス例外発生時は、try-catchで例外処理を行い、例外データをスキップする
** skip-policyで行う
** DBへ更新を行うジョブとする
|
* ジョブが正常終了すること
* DBにより、不正データが更新されていないこと
* ItemProcessorで再処理が発生していること
** 入力データ数よりItemProcessorの実行回数が多いこと

|6
|正常系 +
同期型起動
|チャンクモデルのItemProcessorにおけるスキップ
|
* ItemProcessor実装でビジネス例外が発生するジョブを起動する
* ビジネス例外発生時は、try-catchで例外処理を行い、例外データをスキップする
** ItemProcessorでnullを返却する
** DBへ更新を行うジョブとする
|
* ジョブが正常終了すること
* DBにより、不正データが更新されていないこと
* ItemProcessorで再処理が発生していないこと
** 入力データ数とItemProcessorの実行回数が同じこと

|7
|正常系 +
同期型起動
|タスクレットモデルにおけるスキップ
|
* タスクレット実装でビジネス例外が発生するジョブを起動する
* ビジネス例外発生時は、try-catchで例外処理を行い、例外データをスキップする
** DBへ更新を行うジョブとする
|
* ジョブが正常終了すること
* DBにより、不正データが更新されていないこと

|8
|正常系 +
同期型起動
|リトライ +
規定条件内でリトライが成功する
|
* ItemProcessor実装でリトライ例外が発生するジョブを起動する
** リトライ回数は3回
** リトライ2回目で正常処理となる
** リトライされていることをログ出力する
** RetryTemplateをItemProcssorの実装で利用する
|
* ジョブが正常終了すること
* ログにより、リトライ処理が２回発生したこと

|9
|異常系 +
同期型起動
|リトライ +
規定条件内でリトライが成功しない
|
* ItemProcessor実装でリトライ例外が発生するジョブを起動する
** リトライ回数は3回
** リトライオーバーになる
** リトライされていることをログ出力する
** RetryTemplateをItemProcssorの実装で利用する
|
* ジョブが異常終了すること
* ログにより、リトライ処理が3回発生したこと

|10
|異常系 +
同期型起動
|処理中断 +
スキップ設定時
|
* 項番1と以下の点を除いて同じ
** ItemReaderで発生する例外が、スキップ条件と異なる例外
*** (デフォルトの)`LimitCheckingItemSkipPolicy`を使い、
    `skippable-exception-classes`で発生しない例外を指定する。
|
* ジョブが異常終了すること
* DBにより、不正データが存在するチャンク以降のデータが更新されていない
* ログにより、スキップできなかったこと

|11
|異常系 +
同期型起動
|処理中断 +
リトライ設定時
|
* 項番6と以下の点を除いて同じ
** ItemProcessorで発生する例外が、リトライ条件と異なる例外
*** `RetryPolicy`をデフォルトから差し替える
|
* ジョブが異常終了すること
* DBにより、不正データが存在するチャンク以降のデータが更新されていない
* ログにより、リトライ処理が発生していないこと

|===
