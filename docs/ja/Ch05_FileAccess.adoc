= ファイルアクセスの機能試験
:table-caption!:
:icons: font
:sectnums!:

== テストケース
テストケースクラス：jp.co.ntt.fw.macchinetta.batch.functionaltest.ch05.FileAccessSpec

CAUTION: `sh`を別プロセスで起動するテストケースがあるため、Windows環境で実施する場合はこの点を考慮すること。 +
一つの対応策として、`git for windows`をインストールする際のオプションにて、
`Use Git and optional Unix tools from the Windows Command Prompt:`を有効にすることで、
`Path`変数に`sh`を含めることができる。

CAUTION: 改行コード、文字コードなど環境依存の値を利用するため、試験条件と試験環境については注意すること。
gitで改行を自動変換するようにしている場合など、意図せず条件が変わることがあるので特に注意すること。

[cols="5,25a,70a", options="headers"]
.テストケース一覧
|===
|項番
|テストケース
|確認事項

|1
|<<VariableLengthRecord>>
|
. 可変長レコードの入力
. 可変長レコードの出力

|1-1
|<<VariableLengthRecordRead>>
|
* RFC-4180の仕様をサポートしている
** CSVの仕様だが、可変長レコード全体にも適用できる内容
* レコード種類のバリエーション
** CSV
** TSV
* FieldSetMapperの利用
** FlatFileItemReader共通だが、代表としてここで試験する

|1-2
|<<VariableLengthRecordWrite>>
|
* RFC-4180の仕様をサポートしている
** CSVの仕様だが、可変長レコード全体にも適用できる内容
* レコード種類のバリエーション
** CSV
** TSV

|2
|<<FixedLengthRecord>>
|
. 固定長レコードの入力
. 固定長レコードの出力

|2-1
|<<FixedLengthRecordRead>>
|
* レコード区切り文字が改行である固定文字列長ファイルの読み込み
* レコード区切り文字がない固定文字列長ファイルの読み込み
** レコードをバイト数で指定
* バイト数指定による項目の区切り

|2-2
|<<FixedLengthRecordWrite>>
|
* レコード区切り文字が改行である固定文字列長ファイルの書き込み
* レコード区切り文字がない固定文字列長ファイルの書き込み
* FieldExtractorの利用
** FlatFileItemWriter共通だが、代表としてここで試験する
** 全角文字のフォーマットで必然的にFieldExtractor実装クラスを作成する

|3
|<<passThroughRecord>>
|
* 単一文字列レコードの入力
* 単一文字列レコードの出力

|4
|<<headerFooter>>
|
* ヘッダ
** 入力
*** 読み飛ばし
**** OSコマンドによる読み飛ばしの前処理
*** 内容の取得
** 出力

* フッタ
** 入力
*** 読み飛ばし
**** OSコマンドによる読み飛ばしの前処理
*** 内容の取得
**** フッタを取得するための前処理を実施し、本処理へ引き継ぐ
** 出力

|5
|<<multiResource>>
|
* 同一レコード形式の複数ファイルの入力
* 一定件数ごとの複数ファイルへの出力

|6
|<<xmlFile>>
|
* XMLファイルの入力
** JAXBを使用した入力
* XMLファイルの出力
** JAXBを使用した出力
* スキーマバリデーション

|7
|<<multiLine>>
|
* (Header -> Data -> Trailer) * N -> Footerのパターンの入出力
* マルチフォーマット
** 同一フォーマットも実現方法はおなじため、こちらで試験する


|8
|<<controlBreak>>
|
* SingleItemPeekableItemReaderを使ったコントロールブレーク
** Taskletのみ
** 処理対象のデータ処理前にコントロールブレイクを行う
** 処理対象のデータ処理後にコントロールブレイクを行う

|===

== 試験項目一覧
各試験の項目一覧を示す。

:sectnums:
:leveloffset: -1

[[VariableLengthRecord]]
=== 可変長レコードのテスト
可変長レコードの入出力を確認する。

[[VariableLengthRecordRead]]
==== 可変長レコード入力のテスト
可変長レコードの入力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|RFC-4180の仕様のサポート

* ファイル末尾のレコード終端に改行がない
* レコードの末尾にスペースがある
|
* 試験項目に示したの内容のCSVを読み込む
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しくCSVファイルが読み取れていること

|2
|正常系 +
同期型起動
|RFC-4180の仕様のサポート

* レコードの末尾がカンマ（区切り文字）で終わる
|
* 試験項目に示したの内容のCSVを読み込む
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しくCSVファイルが読み取れていること
** 末尾がnullの項目として取得される

|3
|正常系 +
同期型起動
|RFC-4180の仕様のサポート

* 項目がダブルクォート（囲み文字）で囲まれているものがある
** 囲みあり/なしが混在している
** 囲みありの場合
*** 通常の文字列
*** カンマ（区切り文字）を含む
*** 改行を含む
*** ダブルクォート（囲み文字）を含む
**** 含まれる文字は同一文字（ダブルクォート）でエスケープされている
|
* 試験項目に示したの内容のCSVを読み込む
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しくCSVファイルが読み取れていること

|4
|正常系 +
同期型起動
|TSVの読み込み
|
* 項番1～3の条件を満たす内容のTSVファイルを読み込む
** 区切り文字=タブ(\t)
** 囲み文字=シングルクォート
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しくTSVファイルが読み取れていること

|5
|正常系 +
同期型起動
|FieldSetMapperの実装
|
* 項番1～3の条件を満たす内容のCSVファイルを読み込む
** 区切り文字=カンマ
** 囲み文字=ダブルクォート
* 項目に和暦フォーマットの日付項目を含む
** レコードオブジェクトには日付型として保持する
* 項目にカンマ含みの数字
** レコードオブジェクトには数値型として保持する
* 読み込んだ内容はログ出力する
** 日付項目は、西暦表示とする
** 数値項目は、編集無し
|
* ログ出力により、変換処理が正しく行われたこと

|6
|異常系 +
同期型起動
|BeanWrapperFieldSetMapperの利用
|
* 項番1～3の条件を満たす内容のCSVファイルを読み込む
** 区切り文字=カンマ
** 囲み文字=ダブルクォート
* 項目に和暦フォーマットの日付項目を含む
** レコードオブジェクトには日付型として保持する
* 読み込んだ内容はログ出力する
** 日付項目は、西暦表示とする
|
* ジョブが異常終了する
* ログ出力により、日付変換でエラーが発生すること

|7
|異常系 +
同期型起動
|BeanWrapperFieldSetMapperの利用
|
* 項番1～3の条件を満たす内容のCSVファイルを読み込む
** 区切り文字=カンマ
** 囲み文字=ダブルクォート
* 項目にカンマ含みの数字
** レコードオブジェクトには数値型として保持する
* 読み込んだ内容はログ出力する
** 数値項目は、編集無し
|
* ジョブが異常終了する
* ログ出力により、数値変換でエラーが発生すること

|===

[[VariableLengthRecordWrite]]
==== 可変長レコード出力のテスト
可変長レコードの出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容


|1
|正常系 +
同期型起動
|RFC-4180の仕様のサポート

* レコードの末尾にスペースがある
|
* 末尾がスペースである文字列をレコードの最終項目としてCSV出力する
|
* 出力したファイルにより、スペースが正しく出力されること

|2
|正常系 +
同期型起動
|RFC-4180の仕様のサポート

* 項目がダブルクォート（囲み文字）で囲まれている
** カンマ（区切り文字）を含む
** 改行を含む
** ダブルクォート（囲み文字）を含む
*** 含まれる文字は同一文字（ダブルクォート）でエスケープされている
|
* 以下の文字を含む項目をCSV出力する
** カンマ（区切り文字）を含む
** 改行を含む
** ダブルクォート（囲み文字）を含む
* allEnclosingの設定はfalseとする
|
* 出力ファイルより、試験項目に提示した内容で出力されていること
* 以下の文字を含まない項目は、ダブルクォート（囲み文字）で囲まれていないこと
** カンマ（区切り文字）を含む
** 改行を含む
** ダブルクォート（囲み文字）を含む

|3
|正常系 +
同期型起動
|RFC-4180の仕様のサポート

* 項目がダブルクォート（囲み文字）で囲まれている
** カンマ（区切り文字）を含む
** 改行を含む
** ダブルクォート（囲み文字）を含む
*** 含まれる文字は同一文字（ダブルクォート）でエスケープされている
|
* 以下の文字を含む項目をCSV出力する
** カンマ（区切り文字）を含む
** 改行を含む
** ダブルクォート（囲み文字）を含む
* allEnclosingの設定はtrueとする
|
* 出力ファイルより、試験項目に提示した内容で出力されていること
* 以下の文字を含まない項目も、ダブルクォート（囲み文字）で囲まれていること
** カンマ（区切り文字）を含む
** 改行を含む
** ダブルクォート（囲み文字）を含む

|4
|正常系 +
同期型起動
|TSVの書き込み
|
* 項番1～3の条件を満たす内容のTSVファイルを出力する
** 区切り文字=タブ(\t)
** 囲み文字=シングルクォート
|
* 出力ファイルにより、正しくTSVファイルとして書き込まれていること


|===

[[FixedLengthRecord]]
=== 固定長レコードのテスト
可変長レコードの入出力を確認する。

[[FixedLengthRecordRead]]
==== 固定長レコード入力のテスト
可変長レコードの入力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|レコード区切り文字が改行である固定文字列長ファイルの読み込み
|
* レコード区切り文字が改行である固定文字列長ファイルを読み込む
** ファイルのエンコード=MS932
** ジョブで指定するencoding=MS932
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しく固定長ファイルが読み取れていること

|2
|正常系 +
同期型起動
|レコード区切り文字がない固定文字列長ファイルの読み込み
|
* レコード区切り文字がない固定文字列長ファイルを読み込む
** ファイルのエンコード=MS932
** ジョブで指定するencoding=MS932
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しく固定長ファイルが読み取れていること

|3
|異常系 +
同期型起動
|レコード区切り文字がない固定文字列長ファイルの読み込み
|
* レコード区切り文字がない固定文字列長ファイルを読み込む
** 改行文字(LF)をデータの一部として含む
* ファイルの読み込み時とトークン化時のエンコーディングの指定が一致しない
** ファイルのエンコード=MS932
** ファイルの読み込み=UTF-8
** トークン化=MS932
* 読み込んだ内容はログ出力する

icon:tags[] git clone/pull時に自動変換に注意

|
* ログ出力により、正しく固定長ファイルが読み取れていないこと
** 期待値と異なることを確認

|4
|異常系 +
同期型起動
|レコード区切り文字がある固定文字列長ファイルの読み込み
|
* レコード区切り文字が改行である固定文字列長ファイルを読み込む
** Spring Batch提供の文字数で分割するジョブとする
** ファイルのエンコード=UTF-8
*** サロゲートペアを含む
** ジョブで指定するencoding=UTF-8
* 読み込んだ内容はログ出力する
|
* ログ出力により、正しく固定長ファイルが読み取れていないこと
** 期待値と異なることを確認

|===

[[FixedLengthRecordWrite]]
==== 固定長レコード出力のテスト
可変長レコードの出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|レコード区切り文字が改行である固定文字列長ファイルの書き込み
|
* 半角文字、全角文字混在のデータを固定長出力する
** ファイルのエンコード=MS932
** encoding=MS932
** 項目
*** 半角文字のみ（英数字）
*** 全角文字のみ
*** 半角・全角混在
* 全角文字を含む項目は、FiedlExtactor実装内でフォーマットする
** 文字コードによりバイト数計算をしてパディング・トリム処理をする
* 半角文字はFormmaterLineAggregatorでフォーマットする
|
* 出力ファイルにより、期待した固定長ファイルとして書き込まれていること

|2
|正常系 +
同期型起動
|レコード区切り文字がない固定文字列長ファイルの書き込み
|
* 半角文字、全角文字混在のデータを固定長出力する
** ファイルのエンコード=MS932
** encoding=MS932
** 項目
*** 半角文字のみ（英数字）
*** 全角文字のみ
*** 半角・全角混在
* 全角文字を含む項目は、FiedlExtactor実装内でフォーマットする
** 文字コードによりバイト数計算をしてパディング・トリム処理をする
* 半角文字はFormmaterLineAggregatorでフォーマットする
* lineSeparator=\0を指定する
|
* 出力ファイルにより、期待した固定長ファイルとして書き込まれていること

|3
|正常系 +
同期型起動
|レコード区切り文字としてCRLFが明示された固定文字列長ファイルの書き込み
|
* 半角文字、全角文字混在のデータを固定長出力する
** ファイルのエンコード=MS932
** encoding=MS932
** 項目
*** 半角文字のみ（英数字）
*** 全角文字のみ
*** 半角・全角混在
* lineSeparator=CRLF(XML属性内の文字参照として：&#xD;&#xA;)を指定する
|
* 出力ファイルにより、期待した固定長のレコードが取得でき、末尾がCRLFで改行されていること

|===

[[passThroughRecord]]
=== 単一文字列レコードのテスト
単一文字列レコードの入出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|単一文字列レコードの入力
|
* PassThroughLineMapperを使用して単一文字列レコードとしてファイルを読み込む
* CSVファイルを入力とする
* 読み込んだ内容はログ出力する
|
* ログ出力により、単一文字列としてレコードが読み取れていること

|2
|正常系 +
同期型起動
|単一文字列レコードの出力
|
* DBからデータを取得し、取得したデータオブジェクトを単一文字列レコードとして書き込む
** PassThroughLineAggregatorを利用する
*** 取得したデータオブジェクトのまま渡す(途中でString形式に変換する処理は実装しない)
** データを格納するクラスは、検証しやすいようにtoString()メソッドを実装する

|
* 出力ファイルにより、期待した単一文字列レコードファイルとして書き込まれていること
** toString()メソッドによる出力が書き込まれている

|===


[[headerFooter]]
=== ヘッダとフッタのテスト
ヘッダとフッタの入出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|ヘッダレコードの読み飛ばし
|
* ヘッダレコードを含むCSVファイルを読み込む
** ヘッダもCSV形式とする
** 読み飛ばすヘッダレコードの行数を指定する
* 読み込んだ内容はログ出力する
|
* ログ出力により、ヘッダレコードが読み飛ばされている

|2
|正常系 +
同期型起動
|ヘッダレコードの読み飛ばし
|
* ヘッダレコードを含むCSV形式以外のファイルを読み込む
** ヘッダはCSV形式以外とする
** 読み飛ばすヘッダレコードの行数を指定する
* 読み込んだ内容はログ出力する
|
* ログ出力により、ヘッダレコードが読み飛ばされていること

|3
|正常系 +
同期型起動
|
* OSコマンドによる、ヘッダレコードの読み飛ばし
* OSコマンドによる、フッタレコードの読み飛ばし
|
* head/tailコマンドによる指定行数を読み飛ばす
** head：フッタレコードの読み飛ばし
** tail：ヘッダレコードの読み飛ばし (sedコマンドでもOK)
* ヘッダとフッタのレコードを含むCSVファイルを読み込む
** ヘッダ・フッタもCSV形式とする
** 結果を別ファイルとして出力する
* 出力された別ファイルを読み込むジョブを実行する
** 読み込んだ内容はログ出力する
|
* ログ出力により、ヘッダ・フッタレコードが読み飛ばされている


|4
|正常系 +
同期型起動
|ヘッダレコードの内容取得
|
* ヘッダレコードを含むCSVファイルを読み込む
** ヘッダはCSV形式以外とする
** ヘッダを取得して、executionContextに格納する
* ItemProcessorでexecutionContextからヘッダ情報を取り出し、ログ出力を行う
* 読み込んだ内容はログ出力する
|
* ログ出力により、ヘッダレコードが取得できていること

|5
|正常系 +
同期型起動
|ヘッダレコードの出力

|
* ヘッダレコードを含むCSVファイルを出力する
** ヘッダはCSV形式以外とする
|
* 出力ファイルにより、ヘッダ付きCSVファイルが出力されている

|6
|正常系 +
同期型起動
|フッタレコードの入出力
|
* フッタレコードを含むCSVファイルを入出力する
** フッタは前処理のステップで取得し、本処理のステップへ引き継ぐ
** フッタはCSV形式とする
* 本処理でデータを処理する
** フッタをFlatFileFooterCallbackを使用して、出力を行う
*** 前処理から引き継いだ情報を加工する
** フッタはCSV形式以外とする
|
* 出力ファイルにより、CSV形式以外のフッタ付きCSVファイルが出力されている

|===

[[multiResource]]
=== 複数ファイルのテスト
複数ファイルの入出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|同一レコード形式の複数ファイルの入力
|
* 同一フォルダに同一レコード形式の複数ファイルを配置する
* フォルダ内にあるファイルをMultiResourceItemReaderですべて読み込む
* 読み込んだ内容はログ出力する
|
* ログ出力により、すべてのファイルが読み込まれたこと

|2
|正常系 +
同期型起動
|一定件数ごとの複数ファイルへの出力
|
* chunk-interval = 5のチャンクモデルのジョブ
* DBより21件レコードを取得する
* MultiResourceItemWriterにより複数ファイルへ書き込む
** itemCountLimitPerResource = 4
|
* 出力ファイルにより、チャンクサイズ以内の件数のレコードが書き込まれていること
** 1,2,3,4番目 = 5件のレコード
** 5番目 = 1件のレコード

|3
|正常系 +
同期型起動
|一定件数ごとの複数ファイルへの出力(commit-interval < itemCountLimitPerResourceの場合)
|
* commit-interval = 3のチャンクモデルのジョブ
* DBより21件レコードを取得する
* MultiResourceItemWriterにより複数ファイルへ書き込む
** itemCountLimitPerResource = 4
|
* 出力ファイルにより、
* itemCountLimitPerResourceの件数を超えていない場合、チャンクサイズ以内の件数のレコードが書き込まれていること
* itemCountLimitPerResourceの件数を超えた場合、次のファイルにレコードが書き込まれること
** 1,2,3番目 = 6件のレコード
** 4番目 = 3件のレコード

|===

[[xmlFile]]
=== XMLファイルのテスト
XMLファイルの入出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|JAXBを使用した入力
|
* JAXBを利用してXMLファイルを読み込む
* 読み込んだ内容はログ出力する
|
* ログ出力により、XMLファイルが正しく読み込まれたこと

|2-1
|正常系 +
同期型起動
|JAXBを使用した出力
|
* java8以前（java8を含む）の場合、JAXBを利用してXMLファイルを書き込む
|
* 出力ファイルにより、XMLファイルが正しく書き込まれたこと、standalone=noが出力されないこと

|2-2
|正常系 +
同期型起動
|JAXBを使用した出力
|
* java8以降（java8を含まず）の場合、JAXBを利用してXMLファイルを書き込む
|
* 出力ファイルにより、XMLファイルが正しく書き込まれたこと、standalone=noが出力されること

|3
|正常系 +
同期型起動
|ヘッダとフッタの出力
|
* XMLファイルにヘッダとフッタを書き込む
|
* 出力ファイルにより、ヘッダとフッタが付いたXMLファイルが正しく書き込まれたこと

|4
|正常系 +
同期型起動
|スキーマバリデーション
|
* XMLファイルを読み込む際にスキーマバリデーションを行う
** JAXBを利用してXMLファイルを読み込む
** 読み込んだ内容はログ出力する
|
* ログ出力により、XMLファイルが正しく読み込まれたこと

|5
|異常系 +
同期型起動
|スキーマバリデーション
|
* XMLファイルを読み込む際にスキーマバリデーションを行う
** 読み込むファイルがバリデーションエラーを起こす
|
* ログ出力により、バリデーションエラーが発生したこと

|===

[[multiLine]]
=== マルチラインファイルのテスト
マルチラインファイルの入出力を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|マルチラインファイルの入力
|
* (Header → Data → Trailer) * N → Footerのパターンのマルチラインファイルを読み込む
** Header,Data,Trailer,Footerではレイアウトが異なる（CSVの項目数が異なる）
*** Header,Data,Trailer,Footer別に対応するクラスを用意する
* 読み込んだ内容はログ出力する
|
* ログ出力により、CSVファイルが正しく読み込まれたこと

|2
|正常系 +
同期型起動
|マルチラインファイルの出力
|
* (Header → Data → Trailer) * N → Footerのパターンのマルチラインファイルを読み込む
** Header,Data,Trailer,Footerではレイアウトが異なる（CSVの項目数が異なる）
*** Header,Data,Trailer,Footer別に対応するクラスを用意する
|
* 出力ファイルにより、マルチラインファイルが正しく書き込まれたこと

|===

[[controlBreak]]
=== コントロールブレイクのテスト
コントロールブレイクの実現を確認する。

[cols="5,20,25a,25a,25a", options="header"]
.試験項目一覧
|===
|項番
|観点
|試験項目
|試験条件
|確認内容

|1
|正常系 +
同期型起動
|`SingleItemPeekableItemReader`を使ったコントロールブレーク
|
* 事前にブレイクキーでソートされたファイルを読み込む
** 複数項目でのブレイク
* 読み込んだデータをファイルに出力する
** コントロールブレイクでヘッダ・フッタを出力する

|
* 出力ファイルにより、コントロールブレイクが行われていること

|===
